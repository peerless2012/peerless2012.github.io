<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Peerless2012 by peerless2012</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Peerless2012</h1>
        <h2>Study everyday,be different everyday!</h2>
        <a href="https://github.com/peerless2012" class="button"><small>Follow me on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h2>
            <a id="peerless2012" class="anchor" href="https://github.com/peerless2012" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>Github主页</a>
		  </h2>
            <p>欢迎来到我的主页!</p>
			
		<h2>
            <a id="Realm" class="anchor" href="https://github.com/peerless2012/AndroidBasis/blob/master/Study/%E5%88%9D%E8%AF%86Realm.md" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>初识Realm</a>
		</h2>
			<p>Realm让你能够高效地编写 app 的模型层代码，保证你的数据被安全、快速地存储。</p>	
			<p>它具有<b>跨平台</b>、<b>简单易用</b>、<b>可视化的特点</b>。</p>
			<p>所以，赶快开始吧！</p>
			
		<h2>
            <a id="SafeAsyncTask" class="anchor" href="https://github.com/peerless2012/SafeAsyncTask" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>Android中更安全的使用AsyncTask</a>
		</h2>
			<p>AsyncTask是Android提供的一个异步任务类，他能很方便的实现主线程和工作线程之间的通讯。</p>	
			<p>但是这里面也有一个很大的坑：内存泄露，那么怎么解决呢？</p>
		
		<h2>
            <a id="AutoScrollViewPager" class="anchor" href="https://github.com/peerless2012/AutoScrollViewPager" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>自动无限滚动的ViewPager</a></h2>
			<p>自定义的ViewPager，具有自动滚动并且无限轮播的功能，类似于一般软件主界面广告条效果。使用的时候原来的适配器不需要做任何改变。</p>	
		<h2>
            <a id="AutoScrollListView" class="anchor" href="https://github.com/peerless2012/AutoScrollListView" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>自动无限滚动的ListView</a></h2>
			<p>自定义的ListView，具有自动滚动并且无限轮播的功能，类似于中奖信息轮播的效果。使用起来只需要在原来适配器的基础上实现定义好的一个接口，其他不用做任何改变即可。</p>
		<h2>
            <a id="ServiceStartActivity" class="anchor" href="https://github.com/peerless2012/AndroidBasis/blob/master/problem/Only%20the%20original%20thread%20that%20created%20a%20view%20hierarchy%20can%20touch%20its%20views.%20%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84.md" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>Only the original thread that created a view hierarchy can touch its views. 是怎么产生的</a></h2>

            <p>我们都知道，在Android里面，只有主线程（MainThread）才可以更新ui，比如设置TextView的文本内容，ImageView的图片等等。</p>

			<p>只要我们在非主线程去操作ui界面，就是抛出"Only the original thread that created a view hierarchy can touch its views."的异常。那么这个异常时怎么抛出来的呢？</p>

		<h2>
            <a id="ServiceStartActivity" class="anchor" href="https://github.com/peerless2012/AndroidBasis/blob/master/problem/%E6%9C%8D%E5%8A%A1%E6%88%96%E5%B9%BF%E6%92%AD%E4%B8%AD%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%91%98%E6%BF%80%E6%B4%BB%E7%95%8C%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98.md" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>服务或广播中无法启动设备管理员激活界面的问题</a></h2>

            <p>在Service或者BroadCastReceiver中启动Activity的话需要加上一个Intent.FLAG_ACTIVITY_NEW_TASK标记,一般情况下都是好用的，但是有一个需求是在开机广播中启动设置中的设备管理员激活界面,但是发现无法弹出该页面。</p>

		<h2>
            <a id="RadioGroup" class="anchor" href="https://github.com/peerless2012/AndroidBasis/blob/master/UI/RadioGroup%E7%9A%84onCheckedChanged%E5%9B%9E%E8%B0%83%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%8E%9F%E5%9B%A0.md" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>RadioGroup的onCheckedChanged回调两次的原因</a></h2>

            <p>有的时候我们会使用RadioGroup + RadioButton + Fragment来切换主界面的Fragment,但是我们需要在进入的时候默认选择一个,这个时候就会手动调用RadioGroup的 public void check(int id)方法,但是这个时候我们就会发现public void onCheckedChanged(RadioGroup group, int checkedId);方法会调用两次.当然这肯定不是我们想要的.</p>
        <h2>
            <a id="qingniantuzhai" class="anchor" href="http://peerless2012.github.io/QingNianTuZhai" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>青年图摘</a></h2>

            <p>这是青年图摘得非官方客户端,遵循MD设计原则,欢迎尝鲜!</p>

        <h2>
            <a id="TwoWayNestedScrollView" class="anchor" href="http://peerless2012.github.io/TwoWayNestedScrollView" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>TwoWayNestedScrollView</a></h2>

            <p>我们都知道,Android里面有垂直滑动的ScrollView和水平滑动的HorizontalScrollView,但是我们开发的时候有时候会用到既能水平滑动又能垂直滑动的ScrollView,这就是一个继承了v4包中NestedHorizontalScrollView的</p>

        <h2>
          <a id="SimpleFragment" class="anchor" href="http://peerless2012.github.io/SimpleFragment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>SimpleFragment</a></h2>

          <p>Android中对于Fragment的更优雅的使用方式以及数据传递。</p>

        <h2>
          <a id="SimpleMusic" class="anchor" href="http://peerless2012.github.io/SimpleMusic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link">SimpleMusic</span></a></h2>

          <p>简单的用服务播放音乐，并在界面进行控制。</p>
        </section>

        <aside id="sidebar">


          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>


  </body>
</html>
